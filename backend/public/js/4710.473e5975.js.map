{"version":3,"file":"js/4710.473e5975.js","mappings":"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","sources":["webpack://frontend/./src/services/notificationService.js"],"sourcesContent":["import axios from 'axios'\n\nconst API_BASE_URL = process.env.VUE_APP_API_URL || 'http://127.0.0.1:8000/api'\n\n// Create axios instance with default config\nconst axiosInstance = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 10000, // Default timeout\n  headers: {\n    'Content-Type': 'application/json',\n    Accept: 'application/json'\n  }\n})\n\n// Create a separate instance for notification requests with longer timeout\nconst notificationAxiosInstance = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 30000, // 30 seconds for notification requests\n  headers: {\n    'Content-Type': 'application/json',\n    Accept: 'application/json'\n  }\n})\n\nconst DEBUG = process.env.NODE_ENV === 'development'\n\n// Add auth token to requests for both instances\nconst addAuthInterceptor = (instance) => {\n  instance.interceptors.request.use(\n    (config) => {\n      const token = localStorage.getItem('auth_token')\n      if (token) {\n        config.headers.Authorization = `Bearer ${token}`\n      }\n      return config\n    },\n    (error) => {\n      return Promise.reject(error)\n    }\n  )\n}\n\n// Apply auth interceptor to both instances\naddAuthInterceptor(axiosInstance)\naddAuthInterceptor(notificationAxiosInstance)\n\n// Add anti-cache headers and cache-busting param for GET requests\nconst addNoCacheInterceptor = (instance) => {\n  instance.interceptors.request.use(\n    (config) => {\n      if (config.method && config.method.toLowerCase() === 'get') {\n        try {\n          const url = new URL(config.url, config.baseURL)\n          url.searchParams.set('_cb', String(Date.now()))\n          config.url = url.pathname + url.search\n        } catch (e) {\n          // Fallback: append na√Øve query if URL constructor fails\n          const sep = (config.url || '').includes('?') ? '&' : '?'\n          config.url = `${config.url}${sep}_cb=${Date.now()}`\n        }\n      }\n      return config\n    },\n    (error) => Promise.reject(error)\n  )\n}\n\naddNoCacheInterceptor(axiosInstance)\naddNoCacheInterceptor(notificationAxiosInstance)\n\n// Simple cache to reduce frequent API calls\nconst notificationCache = {\n  data: null,\n  timestamp: null,\n  maxAge: 15000 // 15 seconds cache\n}\n\nconst ENABLE_RESEND =\n  String(process.env.VUE_APP_ENABLE_SMS_RESEND || 'false').toLowerCase() === 'true'\n\nconst notificationService = {\n  /**\n   * Expose feature flag so UIs can disable retry loops when resend is off\n   */\n  isResendEnabled() {\n    return ENABLE_RESEND\n  },\n\n  /**\n   * Resend/notify SMS generically across roles with broad endpoint fallbacks.\n   * NOTE: Backend does not expose any resend/notify endpoints in this project.\n   * We short-circuit to avoid spamming non-existent routes (405/404 floods).\n   */\n  async resendSmsGeneric({ requestId, role = null, target = null, phone = null, channel = 'sms' }) {\n    // Feature flag: allow enabling later without code changes\n\n    if (!ENABLE_RESEND) {\n      if (process.env.NODE_ENV === 'development') {\n        console.warn(\n          'üö´ NotificationService: SMS resend is disabled (no backend endpoints). Skipping network calls.'\n        )\n      }\n      return {\n        success: false,\n        message: 'SMS resend not supported by backend; skipped'\n      }\n    }\n\n    // Build normalization helpers\n    const normalizePhone = (p) => {\n      if (!p) return null\n      const s = String(p).trim()\n      const keepPlus = s.startsWith('+')\n      const digits = s.replace(/[^\\d]/g, '')\n      return keepPlus ? `+${digits}` : digits\n    }\n    const rawPhone = phone || null\n    const normalized = normalizePhone(rawPhone)\n\n    // Payload with many compatibility flags and keys\n    const payload = {\n      request_id: requestId,\n      role,\n      target,\n      notification_type: 'generic_sms',\n      resend_only: true,\n      force: true,\n      force_resend: true,\n      resend_sms: true,\n      send_sms: true,\n      notification_channel: channel,\n      // Phone variants\n      phone: rawPhone || undefined,\n      phone_number: normalized || undefined,\n      recipient_phone: normalized || undefined,\n      destination_phone: normalized || undefined,\n      msisdn: normalized || undefined,\n      contact_phone: normalized || undefined,\n      requester_phone: rawPhone || undefined,\n      requester_phone_number: rawPhone || undefined,\n      staff_phone: rawPhone || undefined,\n      staff_phone_number: rawPhone || undefined\n    }\n\n    // Minimal, explicit allowlist (kept empty until backend adds endpoints)\n    const endpoints = []\n\n    let response\n    let lastError\n    for (let i = 0; i < endpoints.length; i++) {\n      try {\n        if (process.env.NODE_ENV === 'development') {\n          console.log(\n            `üîÑ NotificationService: Trying resend endpoint ${i + 1}/${endpoints.length}:`,\n            endpoints[i]\n          )\n        }\n        response = await notificationAxiosInstance.post(endpoints[i], payload)\n        if (process.env.NODE_ENV === 'development') {\n          console.log('‚úÖ NotificationService: Resend success via', endpoints[i])\n        }\n        return {\n          success: !!response.data?.success,\n          data: response.data?.data,\n          message: response.data?.message\n        }\n      } catch (e) {\n        lastError = e\n        if (process.env.NODE_ENV === 'development') {\n          console.warn(\n            '‚ùå NotificationService: Endpoint failed:',\n            endpoints[i],\n            e.response?.status,\n            e.response?.data?.message || e.message\n          )\n        }\n        continue\n      }\n    }\n\n    return {\n      success: false,\n      message:\n        lastError?.response?.data?.message || lastError?.message || 'No resend endpoints configured'\n    }\n  },\n\n  /**\n   * Get count of pending requests for notification badge (Universal for all roles)\n   */\n  async getPendingRequestsCount(forceRefresh = false) {\n    // Check cache first unless force refresh is requested\n    if (!forceRefresh && notificationCache.data && notificationCache.timestamp) {\n      const cacheAge = Date.now() - notificationCache.timestamp\n      if (cacheAge < notificationCache.maxAge) {\n        if (DEBUG)\n          console.log(\n            'üìã NotificationService: Using cached count (age: ' + Math.round(cacheAge / 1000) + 's)'\n          )\n        return notificationCache.data\n      }\n    }\n\n    let lastError = null\n    const maxRetries = 2\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        if (DEBUG && attempt === 1)\n          console.log('üîÑ NotificationService: Fetching pending requests count...')\n\n        const response = await notificationAxiosInstance.get('/notifications/pending-count')\n\n        if (response.data.success) {\n          if (DEBUG) console.log('‚úÖ NotificationService: Pending count loaded successfully')\n\n          // Cache the successful response\n          notificationCache.data = response.data.data\n          notificationCache.timestamp = Date.now()\n\n          return response.data.data\n        } else {\n          console.error(\n            '‚ùå NotificationService: Failed to load pending count:',\n            response.data.message\n          )\n          lastError = new Error(response.data.message || 'Failed to load pending requests count')\n        }\n      } catch (error) {\n        if (attempt === maxRetries && DEBUG) {\n          console.error(\n            '‚ùå NotificationService: Error fetching pending count:',\n            error?.message || error\n          )\n        }\n\n        // Log more detailed error information\n        if (error.response) {\n          console.error('Response status:', error.response.status)\n          console.error('Response data:', error.response.data)\n          console.error('Response headers:', error.response.headers)\n        }\n\n        lastError = error\n\n        // Don't retry on authentication errors\n        if (error.response?.status === 401 || error.response?.status === 403) {\n          if (DEBUG) console.log('üîê Authentication error - not retrying')\n          break\n        }\n\n        // Don't retry on server errors that are likely persistent\n        if (error.response?.status === 500) {\n          if (DEBUG) console.log('üö´ Server error detected - checking if retryable...')\n          // Only retry server errors once to avoid spam\n          if (attempt >= 2) {\n            if (DEBUG) console.log('üö´ Server error - not retrying further')\n            break\n          }\n        }\n\n        // Add delay before retry (except on last attempt)\n        if (attempt < maxRetries) {\n          if (DEBUG && attempt === 1) console.log(`‚è≥ Retrying in ${attempt * 1000}ms...`)\n          await new Promise((resolve) => setTimeout(resolve, attempt * 1000))\n        }\n      }\n    }\n\n    // All retries failed, handle error\n    if (lastError) {\n      // If we have cached data, use it as fallback\n      if (notificationCache.data) {\n        console.warn('‚ö†Ô∏è NotificationService: Using stale cached data due to API failure')\n        return notificationCache.data\n      }\n\n      // Log the error for debugging but provide graceful fallback\n      if (DEBUG) {\n        console.error('üö´ NotificationService: All retry attempts failed')\n        console.error('Last error details:', {\n          message: lastError.message,\n          status: lastError.response?.status,\n          data: lastError.response?.data\n        })\n      }\n\n      // Provide graceful fallback instead of throwing error\n      // This prevents the UI from breaking when the API is down\n      if (DEBUG)\n        console.warn('üîÑ NotificationService: Providing fallback data to prevent UI breakage')\n      const fallbackData = { total_pending: 0, requires_attention: false, details: null }\n\n      // Cache the fallback for a short time to reduce repeated failed requests\n      notificationCache.data = fallbackData\n      notificationCache.timestamp = Date.now()\n\n      return fallbackData\n    }\n\n    // Fallback to empty result if no cache and no error (shouldn't happen)\n    return { total_pending: 0, requires_attention: false, details: null }\n  },\n\n  /**\n   * Get detailed breakdown of pending requests by stage (Admin only)\n   */\n  async getPendingRequestsBreakdown() {\n    try {\n      if (DEBUG) console.log('üîÑ NotificationService: Fetching pending requests breakdown...')\n      const response = await notificationAxiosInstance.get('/notifications/breakdown')\n\n      if (response.data.success) {\n        if (DEBUG) console.log('‚úÖ NotificationService: Breakdown loaded successfully')\n        return response.data.data\n      } else {\n        console.error('‚ùå NotificationService: Failed to load breakdown:', response.data.message)\n        throw new Error(response.data.message || 'Failed to load breakdown')\n      }\n    } catch (error) {\n      console.error('‚ùå NotificationService: Error fetching breakdown:', error)\n      let errorMessage = 'Network error while loading breakdown'\n\n      if (error.response) {\n        errorMessage = error.response.data?.message || 'Failed to load breakdown'\n      } else if (error.code === 'ECONNABORTED') {\n        errorMessage = 'Request timed out - server may be slow'\n      } else if (error.message.includes('Network Error')) {\n        errorMessage = 'Network connection error'\n      }\n\n      throw new Error(errorMessage)\n    }\n  },\n\n  /**\n   * Clear notification cache (useful for forcing refresh)\n   */\n  clearCache() {\n    if (DEBUG) console.log('üóëÔ∏è NotificationService: Clearing cache')\n    notificationCache.data = null\n    notificationCache.timestamp = null\n  },\n\n  /**\n   * Get role-specific notification settings\n   */\n  getRoleNotificationConfig(roleName) {\n    const roleConfigs = {\n      head_of_department: {\n        routePattern: '/hod-dashboard',\n        menuItems: ['/hod-dashboard/request-list'],\n        description: 'New requests awaiting HOD approval'\n      },\n      divisional_director: {\n        routePattern: '/divisional-dashboard',\n        menuItems: ['/divisional-dashboard/combined-requests'],\n        description: 'HOD-approved requests awaiting divisional approval'\n      },\n      ict_director: {\n        routePattern: '/dict-dashboard',\n        menuItems: ['/dict-dashboard/combined-requests'],\n        description: 'Divisional-approved requests awaiting ICT Director approval'\n      },\n      head_of_it: {\n        routePattern: '/head_of_it-dashboard',\n        menuItems: ['/head_of_it-dashboard/combined-requests'],\n        description: 'ICT Director-approved requests awaiting Head of IT approval'\n      },\n      ict_officer: {\n        routePattern: '/ict-dashboard',\n        menuItems: ['/ict-dashboard/access-requests'],\n        description: 'Requests requiring implementation (excludes implemented/completed)'\n      },\n      admin: {\n        routePattern: '/admin-dashboard',\n        menuItems: ['/admin-dashboard', '/service-users'],\n        description: 'System-wide pending requests'\n      }\n    }\n\n    return (\n      roleConfigs[roleName] || {\n        routePattern: '/user-dashboard',\n        menuItems: [],\n        description: 'No pending approval tasks'\n      }\n    )\n  },\n\n  /**\n   * Check if a route should show notification badge for the current user role\n   */\n  shouldShowNotificationForRoute(routePath, userRole) {\n    const config = this.getRoleNotificationConfig(userRole)\n    return config.menuItems.includes(routePath)\n  }\n}\n\nexport default notificationService\n"],"names":["API_BASE_URL","process","axiosInstance","axios","create","baseURL","timeout","headers","Accept","notificationAxiosInstance","DEBUG","addAuthInterceptor","instance","interceptors","request","use","config","token","localStorage","getItem","Authorization","error","Promise","reject","addNoCacheInterceptor","method","toLowerCase","url","URL","searchParams","set","String","Date","now","pathname","search","e","sep","includes","notificationCache","data","timestamp","maxAge","ENABLE_RESEND","VUE_APP_ENABLE_SMS_RESEND","notificationService","isResendEnabled","resendSmsGeneric","requestId","role","target","phone","channel","success","message","normalizePhone","p","s","trim","keepPlus","startsWith","digits","replace","rawPhone","normalized","payload","request_id","notification_type","resend_only","force","force_resend","resend_sms","send_sms","notification_channel","undefined","phone_number","recipient_phone","destination_phone","msisdn","contact_phone","requester_phone","requester_phone_number","staff_phone","staff_phone_number","endpoints","response","lastError","i","length","post","getPendingRequestsCount","forceRefresh","cacheAge","Math","round","maxRetries","attempt","get","console","Error","status","resolve","setTimeout","warn","fallbackData","total_pending","requires_attention","details","getPendingRequestsBreakdown","errorMessage","code","clearCache","getRoleNotificationConfig","roleName","roleConfigs","head_of_department","routePattern","menuItems","description","divisional_director","ict_director","head_of_it","ict_officer","admin","shouldShowNotificationForRoute","routePath","userRole","this"],"sourceRoot":""}