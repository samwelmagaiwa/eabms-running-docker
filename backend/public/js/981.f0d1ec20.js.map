{"version":3,"file":"js/981.f0d1ec20.js","mappings":"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","sources":["webpack://frontend/./src/services/authService.js"],"sourcesContent":["import axios from 'axios'\n\nconst API_BASE_URL = process.env.VUE_APP_API_URL || 'http://localhost:8000/api'\n\n// Create axios instance with default config\nconst apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: parseInt(process.env.VUE_APP_API_TIMEOUT) || 10000,\n  headers: {\n    'Content-Type': 'application/json',\n    Accept: 'application/json'\n  }\n})\n\n// Add auth token to requests\napiClient.interceptors.request.use(\n  (config) => {\n    const token = localStorage.getItem('auth_token')\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`\n    }\n    return config\n  },\n  (error) => {\n    return Promise.reject(error)\n  }\n)\n\n// Handle response errors\napiClient.interceptors.response.use(\n  (response) => response,\n  (error) => {\n    const status = error.response?.status\n    const method = (error.config?.method || '').toString().toLowerCase()\n    const url = (error.config?.url || '').toString()\n\n    if (status === 401) {\n      // IMPORTANT: Do NOT auto-redirect on login failures, so the login\n      // page can display \"Invalid email or password\" in the shared error banner.\n      const isLoginRequest = method === 'post' && url.includes('/login')\n\n      if (!isLoginRequest) {\n        // Token expired or invalid on authenticated routes\n        localStorage.removeItem('auth_token')\n        localStorage.removeItem('user_data')\n        localStorage.removeItem('session_data')\n        window.location.href = '/login'\n      }\n    }\n\n    return Promise.reject(error)\n  }\n)\n\nexport const authService = {\n  /**\n   * Login user with email and password\n   * @param {Object} credentials - { email, password }\n   * @returns {Promise<Object>} - Login response\n   */\n  async login(credentials) {\n    try {\n      const response = await apiClient.post('/login', credentials)\n      return {\n        success: true,\n        data: response.data\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Login failed',\n        errors: error.response?.data?.errors || {}\n      }\n    }\n  },\n\n  /**\n   * Logout current user\n   * @returns {Promise<Object>} - Logout response\n   */\n  async logout() {\n    try {\n      const response = await apiClient.post('/logout')\n      return {\n        success: true,\n        data: response.data\n      }\n    } catch (error) {\n      // Even if logout API fails, we should clear local state\n      return {\n        success: true,\n        message: 'Logged out locally (API call failed)'\n      }\n    }\n  },\n\n  /**\n   * Logout from all sessions\n   * @returns {Promise<Object>} - Logout all response\n   */\n  async logoutAll() {\n    try {\n      const response = await apiClient.post('/logout-all')\n      return {\n        success: true,\n        data: response.data\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Logout all failed'\n      }\n    }\n  },\n\n  /**\n   * Get current user data\n   * @returns {Promise<Object>} - User data response\n   */\n  async getCurrentUser() {\n    try {\n      const response = await apiClient.get('/current-user')\n      return {\n        success: true,\n        data: response.data\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Failed to get user data',\n        status: error.response?.status\n      }\n    }\n  },\n\n  /**\n   * Get role-based redirect URL\n   * @returns {Promise<Object>} - Redirect URL response\n   */\n  async getRoleBasedRedirect() {\n    try {\n      const response = await apiClient.get('/role-redirect')\n      return {\n        success: true,\n        data: response.data\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Failed to get redirect URL',\n        status: error.response?.status\n      }\n    }\n  },\n\n  /**\n   * Get active sessions\n   * @returns {Promise<Object>} - Active sessions response\n   */\n  async getActiveSessions() {\n    try {\n      const response = await apiClient.get('/active-sessions')\n      return {\n        success: true,\n        data: response.data\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Failed to get active sessions'\n      }\n    }\n  },\n\n  /**\n   * Revoke a specific session\n   * @param {number} tokenId - Token ID to revoke\n   * @returns {Promise<Object>} - Revoke session response\n   */\n  async revokeSession(tokenId) {\n    try {\n      const response = await apiClient.post('/revoke-session', {\n        token_id: tokenId\n      })\n      return {\n        success: true,\n        data: response.data\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Failed to revoke session'\n      }\n    }\n  },\n\n  /**\n   * Change password for the currently authenticated user\n   * @param {{ current: string, new: string, confirm: string }} payload\n   * @returns {Promise<Object>} - Change password response\n   */\n  async changePassword(payload) {\n    try {\n      const response = await apiClient.post('/change-password', {\n        current_password: payload.current,\n        password: payload.new,\n        password_confirmation: payload.confirm\n      })\n      return {\n        success: true,\n        data: response.data,\n        message: response.data?.message || 'Password changed successfully.'\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Failed to change password.',\n        errors: error.response?.data?.errors || {}\n      }\n    }\n  },\n\n  /**\n   * Request password reset OTP by phone (public, no auth)\n   * @param {string} phone\n   * @returns {Promise<Object>}\n   */\n  async requestPasswordResetByPhone(phone) {\n    try {\n      const response = await apiClient.post('/password-reset/request-by-phone', { phone })\n      return {\n        success: true,\n        data: response.data,\n        message: response.data?.message\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Failed to send OTP.',\n        errors: error.response?.data?.errors || {}\n      }\n    }\n  },\n\n  /**\n   * Verify password reset OTP (phone + otp)\n   * @param {{ phone: string, otp: string }} payload\n   * @returns {Promise<Object>}\n   */\n  async verifyPasswordResetOtp(payload) {\n    try {\n      const response = await apiClient.post('/password-reset/verify-otp', {\n        phone: payload.phone,\n        otp: payload.otp\n      })\n      return {\n        success: true,\n        data: response.data,\n        message: response.data?.message\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Failed to verify OTP.',\n        errors: error.response?.data?.errors || {}\n      }\n    }\n  },\n\n  /**\n   * Reset password using phone + OTP, returns { user, token }\n   * @param {{ phone: string, otp: string, password: string, password_confirmation: string }} payload\n   * @returns {Promise<Object>}\n   */\n  async resetPasswordWithOtp(payload) {\n    try {\n      const response = await apiClient.post('/password-reset/reset-with-otp', {\n        phone: payload.phone,\n        otp: payload.otp,\n        password: payload.password,\n        password_confirmation: payload.password_confirmation\n      })\n      return {\n        success: true,\n        data: response.data?.data,\n        message: response.data?.message\n      }\n    } catch (error) {\n      return {\n        success: false,\n        message: error.response?.data?.message || 'Failed to reset password.',\n        errors: error.response?.data?.errors || {}\n      }\n    }\n  }\n}\n\nexport default authService\n"],"names":["API_BASE_URL","process","apiClient","axios","create","baseURL","timeout","parseInt","headers","Accept","interceptors","request","use","config","token","localStorage","getItem","Authorization","error","Promise","reject","response","status","method","toString","toLowerCase","url","isLoginRequest","includes","removeItem","window","location","href","authService","login","credentials","post","success","data","message","errors","logout","logoutAll","getCurrentUser","get","getRoleBasedRedirect","getActiveSessions","revokeSession","tokenId","token_id","changePassword","payload","current_password","current","password","new","password_confirmation","confirm","requestPasswordResetByPhone","phone","verifyPasswordResetOtp","otp","resetPasswordWithOtp"],"ignoreList":[],"sourceRoot":""}